(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{234:function(v,_,e){"use strict";e.r(_);var t=e(0),o=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"浏览器渲染原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染原理"}},[v._v("#")]),v._v(" 浏览器渲染原理")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("浏览器使用流式布局模型。")])]),v._v(" "),e("li",[e("p",[v._v("浏览器会把 "),e("code",[v._v("HTML")]),v._v(" 解析生成 "),e("code",[v._v("DOM树")]),v._v("，把 "),e("code",[v._v("CSS")]),v._v(" 解析成 "),e("code",[v._v("CSSOM")]),v._v("，"),e("code",[v._v("DOM")]),v._v(" 和 "),e("code",[v._v("CSSOM")]),v._v(" 合并成 "),e("code",[v._v("Render Tree")]),v._v("。")])]),v._v(" "),e("li",[e("p",[v._v("有了 "),e("code",[v._v("Render Tree")]),v._v(" 之后，就知道了所有节点的样式，然后计算出在页面上的大小位置颜色等等，最后绘制节点。")])]),v._v(" "),e("li",[e("p",[v._v("由于浏览器使用流式布局，对 "),e("code",[v._v("Render Tree")]),v._v(" 的计算通常只需要遍历一次就可以完成，但是 "),e("code",[v._v("table")]),v._v(" 及其内部的元素除外，可能需要多次计算，越等同于3倍的其他元素的时间。")])])]),v._v(" "),e("h2",{attrs:{id:"回流（重排）（reflow）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流（重排）（reflow）"}},[v._v("#")]),v._v(" 回流（重排）（Reflow）")]),v._v(" "),e("p",[v._v("当 "),e("code",[v._v("Render Tree")]),v._v(" 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器会重新渲染部分或全部文档的过程称为回流。")]),v._v(" "),e("p",[e("strong",[v._v("会触发回流的操作：")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("页面首次渲染。")])]),v._v(" "),e("li",[e("p",[v._v("浏览器视窗大小发生改变。")])]),v._v(" "),e("li",[e("p",[v._v("元素的尺寸或者位置发生变化。")])]),v._v(" "),e("li",[e("p",[v._v("元素的内容发生变化（文字数量或者图片大小等）。")])]),v._v(" "),e("li",[e("p",[v._v("元素字体大小发生改变。")])]),v._v(" "),e("li",[e("p",[v._v("添加或删除可见的DOM元素。")])]),v._v(" "),e("li",[e("p",[v._v("激活CSS伪类，比如 "),e("code",[v._v(":hover")]),v._v("。")])]),v._v(" "),e("li",[e("p",[v._v("查询某些属性或者调用某些方法。")])])]),v._v(" "),e("p",[e("strong",[v._v("常用的且会导致回流的属性或方法：")])]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("clientWidth")]),v._v(" "),e("code",[v._v("clientHeight")]),v._v(" "),e("code",[v._v("clientTop")]),v._v(" "),e("code",[v._v("clientLeft")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("offsetTop")]),v._v(" "),e("code",[v._v("offsetLeft")]),v._v(" "),e("code",[v._v("offsetwidth")]),v._v(" "),e("code",[v._v("offsetHeight")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("scrollWidth")]),v._v(" "),e("code",[v._v("scrollHeight")]),v._v(" "),e("code",[v._v("scrollLeft")]),v._v(" "),e("code",[v._v("scrollTop")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("scrollIntoView()")]),v._v(" "),e("code",[v._v("scrollIntoViewIfNeeded()")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("getComputedStyle()")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("getBoundingClientRect()")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("scrollTo")])])])]),v._v(" "),e("h2",{attrs:{id:"重绘（repaint）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘（repaint）"}},[v._v("#")]),v._v(" 重绘（Repaint）")]),v._v(" "),e("p",[v._v("当页面中的元素样式改变并不影响它在文档中的位置时，浏览器会重新绘制它的样式，这个过程叫做重绘。")]),v._v(" "),e("h2",{attrs:{id:"性能影响"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能影响"}},[v._v("#")]),v._v(" 性能影响")]),v._v(" "),e("p",[e("strong",[v._v("回流比重绘的代价要高得多。")])]),v._v(" "),e("p",[v._v("有时即使回流一个单一元素，它的父元素以及其他的跟随它的元素也会跟着一起回流。")]),v._v(" "),e("h2",{attrs:{id:"现代浏览器优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#现代浏览器优化"}},[v._v("#")]),v._v(" 现代浏览器优化")]),v._v(" "),e("p",[v._v("现代浏览器本身会频繁的对回流或重绘操作进行优化。")]),v._v(" "),e("p",[v._v("浏览器会维护一个队列，把所有的重绘和回流操作放入队列中，如果队列的任务数量或者时间间隔达到一个阈值，浏览器就会清空队列，进行一次批处理，这样可以把多次操作合并为一次。")]),v._v(" "),e("p",[e("strong",[v._v("立即清理队列的操作：")])]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("clientWidth")]),v._v(" "),e("code",[v._v("clientHeight")]),v._v(" "),e("code",[v._v("clientTop")]),v._v(" "),e("code",[v._v("clientLeft")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("offsetTop")]),v._v(" "),e("code",[v._v("offsetLeft")]),v._v(" "),e("code",[v._v("offsetwidth")]),v._v(" "),e("code",[v._v("offsetHeight")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("scrollWidth")]),v._v(" "),e("code",[v._v("scrollHeight")]),v._v(" "),e("code",[v._v("scrollLeft")]),v._v(" "),e("code",[v._v("scrollTop")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("width")]),v._v(" "),e("code",[v._v("height")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("getComputedStyle()")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("getBoundingClientRect()")])])])]),v._v(" "),e("p",[v._v("因为队列中可能有会影响到这些属性或者方法返回值的操作，即使你希望获取的信息与队列中操作所引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。")]),v._v(" "),e("h2",{attrs:{id:"如何避免"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何避免"}},[v._v("#")]),v._v(" 如何避免")]),v._v(" "),e("h3",{attrs:{id:"css"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[v._v("#")]),v._v(" CSS")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("尽量避免 "),e("code",[v._v("table")]),v._v(" 布局。")])]),v._v(" "),e("li",[e("p",[v._v("尽可能在DOM树的末端修改class。")])]),v._v(" "),e("li",[e("p",[v._v("避免设置多层内联样式。")])]),v._v(" "),e("li",[e("p",[v._v("将动画效果应用到 "),e("code",[v._v("position")]),v._v(" 为 "),e("code",[v._v("fixed")]),v._v(" 或 "),e("code",[v._v("absolute")]),v._v(" 的元素中。")])]),v._v(" "),e("li",[e("p",[v._v("尽量避免使用css表达式 "),e("code",[v._v("calc")]),v._v("。")])])]),v._v(" "),e("h3",{attrs:{id:"javascript"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[v._v("#")]),v._v(" JavaScript")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("尽量避免频繁的操作样式，最好一次性重写style样式，或者更改class且一次性修改。")])]),v._v(" "),e("li",[e("p",[v._v("尽量避免频繁的操作DOM，创建一个 "),e("code",[v._v("documentFragment")]),v._v("，在它上面进行DOM操作，最后提交到文档中。")])]),v._v(" "),e("li",[e("p",[v._v("可以将元素先设置为 "),e("code",[v._v("display: block;")]),v._v("，操作结束后再显示出来。")])]),v._v(" "),e("li",[e("p",[v._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用最好用变量缓存。")])]),v._v(" "),e("li",[e("p",[v._v("对具有复杂动画的元素使用绝对定位脱离文档流，否则会引起父元素及后续元素频繁的回流。")])])])])}),[],!1,null,null,null);_.default=o.exports}}]);