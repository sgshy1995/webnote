(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{302:function(t,v,h){"use strict";h.r(v);var e=h(0),_=Object(e.a)({},(function(){var t=this,v=t.$createElement,h=t._self._c||v;return h("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[h("h2",{attrs:{id:"两种模式：history-和-hash"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#两种模式：history-和-hash"}},[t._v("#")]),t._v(" 两种模式："),h("code",[t._v("history")]),t._v(" 和 "),h("code",[t._v("hash")])]),t._v(" "),h("h3",{attrs:{id:"判断浏览器是否支持-history"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#判断浏览器是否支持-history"}},[t._v("#")]),t._v(" 判断浏览器是否支持 "),h("code",[t._v("history")])]),t._v(" "),h("p",[h("code",[t._v("window.supportsPushState")])]),t._v(" "),h("h3",{attrs:{id:"hash-模式"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash-模式"}},[t._v("#")]),t._v(" "),h("code",[t._v("hash")]),t._v(" 模式")]),t._v(" "),h("p",[t._v("默认为hash模式。")]),t._v(" "),h("p",[t._v("使用URL的hash来模拟一个完整的URL，当URL改变时，页面不会重新加载。hash（#）是URL的锚点，代表的是网页中的一个位置。")]),t._v(" "),h("p",[t._v("单单改变#后面的部分，浏览器只会滚动到相应位置，不会重新加载页面；也就是说hash出现在URL中，但不会包含在http请求路径中，所以他的改变不会重载页面；同时每一次更改hash，都会在浏览器里增加一个历史记录，使用前进或者后退就会回到不同的历史位置。")]),t._v(" "),h("p",[t._v("hash模式的原理是通过直接赋值"),h("code",[t._v("location.hash")]),t._v("或调用"),h("code",[t._v("window.location.replace")]),t._v("来修改hash值，触发更新，通过"),h("code",[t._v("hashchange事件")]),t._v("（检测#后面的hash的变化）监听浏览器的前进或后退，可以在"),h("code",[t._v("window")]),t._v("对象上监听这个事件。")]),t._v(" "),h("h3",{attrs:{id:"history-模式"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#history-模式"}},[t._v("#")]),t._v(" "),h("code",[t._v("history")]),t._v(" 模式")]),t._v(" "),h("p",[t._v("由于 "),h("code",[t._v("hash")]),t._v(" 模式会在URL中自带#，如果不想要很丑的hash，可以用 "),h("code",[t._v("history")]),t._v(" 模式。")]),t._v(" "),h("p",[t._v("HTML5的 "),h("code",[t._v("history infterface")]),t._v(" 中新增了 "),h("code",[t._v("pushState()")]),t._v(" 和 "),h("code",[t._v("replaceState()")]),t._v(" 方法，这两个方法应用于浏览器记录栈，提供了对历史记录修改的功能。只是他们执行修改时，虽然改变了URL（同源），但是不会发出请求。同时还有 "),h("code",[t._v("popstate")]),t._v(" 事件。")]),t._v(" "),h("p",[t._v("history模式的原理是 "),h("code",[t._v("history.pushState()")]),t._v(" 和 "),h("code",[t._v("history.replaceState()")]),t._v(" 来改变URL并添加/替换到历史记录中，通过 "),h("code",[t._v("popstate")]),t._v(" 事件监听浏览器的前进或后退，触发更新。")]),t._v(" "),h("h2",{attrs:{id:"如何渲染-router-view-组件"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#如何渲染-router-view-组件"}},[t._v("#")]),t._v(" 如何渲染 "),h("code",[t._v("router-view")]),t._v(" 组件")]),t._v(" "),h("p",[t._v("1、通过"),h("code",[t._v("Vue.observable")]),t._v("在router实例上创建一个保存当前路由的监控对象current。")]),t._v(" "),h("p",[t._v("2、当浏览器地址变化的时候，修改监控对象current。")]),t._v(" "),h("p",[t._v("3、在router-view组件中监听监控对象current的变化，当current变化后，获取用户注册的相应component，并利用h函数将component渲染成vnodes，进而更新页面视图。")]),t._v(" "),h("h2",{attrs:{id:"两种模式的区别"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#两种模式的区别"}},[t._v("#")]),t._v(" 两种模式的区别")]),t._v(" "),h("ul",[h("li",[h("p",[t._v("hash只能改变 "),h("code",[t._v("#")]),t._v(" 后面的值，而history可以随意设置"),h("code",[t._v("同源")]),t._v("的url。")])]),t._v(" "),h("li",[h("p",[t._v("hash只能添加"),h("code",[t._v("字符串类")]),t._v("的数据，而history可以"),h("code",[t._v("通过API添加多种类型")]),t._v("的数据。")])]),t._v(" "),h("li",[h("p",[t._v("hash变化才可加入历史记录，history可以相同的url重复加入history。")])]),t._v(" "),h("li",[h("p",[t._v("hash无需后端配置且兼容性良好，而history需要配置index.html用于匹配不到资源的情况，一般需要配置404。")])])])])}),[],!1,null,null,null);v.default=_.exports}}]);