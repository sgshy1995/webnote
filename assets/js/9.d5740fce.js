(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{215:function(a,e,t){"use strict";t.r(e);var v=t(0),_=Object(v.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"两者的定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两者的定义"}},[a._v("#")]),a._v(" 两者的定义")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("map()")]),a._v(" 方法创建一个新的数组，其返回结果是新数组的每一项的回调函数的返回值。")])]),a._v(" "),t("p",[t("code",[a._v("map()")]),a._v(" 方法会给原数组中的每个元素都按顺序调用一次  callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("forEach()")]),a._v(" 方法是对数组里面的每一项执行一次给定的函数。")])]),a._v(" "),t("p",[t("code",[a._v("forEach()")]),a._v(" 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。")]),a._v(" "),t("h2",{attrs:{id:"对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[a._v("#")]),a._v(" 对比")]),a._v(" "),t("ul",[t("li",[t("p",[t("code",[a._v("forEach()")]),a._v(" 返回值为 "),t("code",[a._v("undefined")]),a._v("，不可链式调用。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("map()")]),a._v(" 会得到一个新的数组并返回，当然可以链式调用。")])])]),a._v(" "),t("p",[a._v("所以， 如果你不打算使用返回的新数组， 却依旧使用 "),t("code",[a._v("map()")]),a._v(" 的话， 这是违背 "),t("code",[a._v("map()")]),a._v(" 的设计初衷的。")])])}),[],!1,null,null,null);e.default=_.exports}}]);