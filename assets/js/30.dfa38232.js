(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{241:function(v,_,e){"use strict";e.r(_);var t=e(0),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"什么是虚拟dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟dom"}},[v._v("#")]),v._v(" 什么是虚拟DOM")]),v._v(" "),e("p",[v._v("一个可以代表DOM树的对象，通常包括标签名、标签上的属性、类名、事件监听、子元素们等属性。")]),v._v(" "),e("h2",{attrs:{id:"虚拟dom的优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom的优点"}},[v._v("#")]),v._v(" 虚拟DOM的优点")]),v._v(" "),e("h3",{attrs:{id:"减少不必要的dom操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#减少不必要的dom操作"}},[v._v("#")]),v._v(" 减少不必要的DOM操作")]),v._v(" "),e("p",[v._v("可以减少不必要的DOM操作，提高性能。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("可以将多次的DOM操作做合并为一次，比如一次性添加1000个元素。")])]),v._v(" "),e("li",[e("p",[v._v("借助 "),e("code",[v._v("DOM diff")]),v._v(" 可以把多余的操作省略掉，比如添加1000个元素，但其中的990个都是重复的，相比直接 "),e("code",[v._v("innerHTML")]),v._v(" 要高效。")])])]),v._v(" "),e("h3",{attrs:{id:"可以跨平台渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可以跨平台渲染"}},[v._v("#")]),v._v(" 可以跨平台渲染")]),v._v(" "),e("p",[v._v("虚拟DOM不仅可以变成真实的DOM，还可以变成小程序、Android应用、IOS应用等，因为虚拟DOM本质上是一个JS的对象。")]),v._v(" "),e("h2",{attrs:{id:"虚拟dom的缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom的缺点"}},[v._v("#")]),v._v(" 虚拟DOM的缺点")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("需要额外的创建函数，比如 "),e("code",[v._v("React")]),v._v(" 的 "),e("code",[v._v("createElement")]),v._v(" 或者 "),e("code",[v._v("Vue")]),v._v(" 的 "),e("code",[v._v("h")]),v._v("。但可以通过 "),e("code",[v._v("JSX")]),v._v(" 来简化成 "),e("code",[v._v("XML")]),v._v(" 的写法使用，或者用 "),e("code",[v._v("vue-loader")]),v._v(" 转译模板语法。")])]),v._v(" "),e("li",[e("p",[v._v("严重依赖预打包工具，要添加额外的构建过程。")])])]),v._v(" "),e("h2",{attrs:{id:"虚拟dom和真实dom的对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom和真实dom的对比"}},[v._v("#")]),v._v(" 虚拟DOM和真实DOM的对比")]),v._v(" "),e("p",[v._v("一般来说，一个页面正常的DOM节点一般在2000-10000之间，当DOM数量比较少时，虚拟DOM可以有更高的性能；但是在数量远超常规时，虚拟DOM的对比算法可能反而会适得其反。")]),v._v(" "),e("h2",{attrs:{id:"dom-diff"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dom-diff"}},[v._v("#")]),v._v(" DOM diff")]),v._v(" "),e("p",[e("code",[v._v("DOM diff")]),v._v(" 就是虚拟DOM的对比算法（函数）。")]),v._v(" "),e("h3",{attrs:{id:"dom-diff-的的大概逻辑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dom-diff-的的大概逻辑"}},[v._v("#")]),v._v(" DOM diff 的的大概逻辑")]),v._v(" "),e("ul",[e("li",[v._v("Tree diff")])]),v._v(" "),e("p",[v._v("将两个DOM树逐层对比，找出那些节点需要需要更新。")]),v._v(" "),e("p",[v._v("如果节点是组件，就看 Component diff。")]),v._v(" "),e("p",[v._v("如果节点是元素，就看 Element diff。")]),v._v(" "),e("ul",[e("li",[v._v("Component diff")])]),v._v(" "),e("p",[v._v("如果节点是组件，先看组件类型有没有变化。")]),v._v(" "),e("p",[v._v("如果类型不同直接替换，删除旧的组件。")]),v._v(" "),e("p",[v._v("类型相同对比属性，如果属性不同则更新属性。")]),v._v(" "),e("p",[v._v("然后递归深入，在进行一次 Tree diff。")]),v._v(" "),e("ul",[e("li",[v._v("Element diff")])]),v._v(" "),e("p",[v._v("如果节点是元素，先看元素的标签名有无变化。")]),v._v(" "),e("p",[v._v("如果标签类型变化，则直接替换，删除旧的元素。")]),v._v(" "),e("p",[v._v("类型相同对比属性，如果属性不同则更新属性。")]),v._v(" "),e("p",[v._v("然后递归深入，在进行一次 Tree diff。")]),v._v(" "),e("h3",{attrs:{id:"dom-diff-的-key-问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dom-diff-的-key-问题"}},[v._v("#")]),v._v(" DOM diff 的 key 问题")]),v._v(" "),e("p",[v._v("Vue 的 "),e("code",[v._v("v-for")]),v._v(" 中的 "),e("code",[v._v("key")]),v._v(" 和 React 中的元素的 "),e("code",[v._v("key")]),v._v(" 都适用于 DOM diff 去对比更新DOM。")]),v._v(" "),e("p",[e("code",[v._v("key")]),v._v(" 要制定唯一值，避免直接使用数组的下标，因为下标是会变的。")])])}),[],!1,null,null,null);_.default=a.exports}}]);