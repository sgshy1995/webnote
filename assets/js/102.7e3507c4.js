(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{299:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"watch-和-computed"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch-和-computed"}},[t._v("#")]),t._v(" watch 和 computed")]),t._v(" "),e("h3",{attrs:{id:"computed"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),e("ul",[e("li",[t._v("计算属性")]),t._v(" "),e("li",[t._v("用来计算出一个值，在调用时不需要加括号，可以当做属性用")]),t._v(" "),e("li",[t._v("根据依赖自动缓存，在 getter 后缓存")])]),t._v(" "),e("h3",{attrs:{id:"watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")]),t._v(" "),e("ul",[e("li",[t._v("有两个选项：deep(监听对象时是否看其内部属性的变化) 和 immediate(是否在第一次渲染时执行函数)")]),t._v(" "),e("li",[t._v("当依赖 data 变化时执行回调，传入两个值 oldValue 和 newValue")]),t._v(" "),e("li",[t._v("可以使用 $watch()方法")])]),t._v(" "),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("ul",[e("li",[t._v("如果一个数据依赖于其他数据，把该数据设计为 computed")]),t._v(" "),e("li",[t._v("如果需要在某个数据变化时做一些事情，使用 watch 来观察其变化来执行回调")])])])}),[],!1,null,null,null);a.default=s.exports}}]);